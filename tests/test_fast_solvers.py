
import unittest
import numpy as np
import sys
import os
import time

# Ensure we import the local modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

try:
    import holo_api
except ImportError:
    sys.path.append("..")
    import holo_api

class TestFastSolvers(unittest.TestCase):
    def setUp(self):
        if not holo_api.GPU_AVAILABLE:
            self.skipTest("GPU not available")
            
        self.width = 128
        self.height = 128
        self.seed = 42
        
        # Create synthetic image (a white square)
        self.tx_img = np.zeros((self.height, self.width), dtype=np.uint8)
        self.tx_img[32:96, 32:96] = 200
        
        # Generate measurements using STANDARD TX (slow/memory bound, but reference)
        # Note: Fast solver uses DIFFERENT RNG, so we cannot use the standard TX measurements!
        # The Fast Solver assumes the Forward Operator (Ax) matches its own internal logic.
        # WAIT. A Solver solves Ax = b.
        # If I use `Fast Solver`, it uses `kernel_Ax_fast` which uses `get_mask_val`.
        # The `b` must be generated by a Transmitter that ALSO uses `get_mask_val` logic.
        # The current `HoloTx` uses `curand` + `float_to_mask`.
        # THEY ARE INCOMPATIBLE.
        
        # ERROR IN PLAN:
        # The Fast Solver optimization implicitly changed the Forward Operator A.
        # This means the Transmitter MUST also be updated to use the new lightweight PRNG logic
        # OR I must implement a "Fast Transmitter" mode.
        
        # Correct approach:
        # I need `tx_generate_fast` in `holo_cuda.cu` that uses the same `get_mask_val`.
        # And `HoloTx` needs a `fast=True` option.
        
        # For this test, I can cheat by simulating the "Fast TX" using the "Fast Solver" itself?
        # A solver usually has methods to apply A and A^T.
        # But `holo_api` solver doesn't expose `apply_A`.
        
        # BETTER: I need to update `holo_cuda.cu` to include `tx_generate_fast`.
        pass


    def test_compare_fast_vs_slow(self):
        from utils import ssim_metric
        # 1. Standard CGLS (Reference)
        # We need standard measurements for standard solver
        tx_std = holo_api.HoloTx(self.seed, self.width, self.height, self.tx_img)
        n_meas = 2000 # Small number for speed
        meas_std = tx_std.generate(n_meas, fast=False)
        tx_std.close()
        
        rx_std = holo_api.HoloRx(self.seed, self.width, self.height)
        solver_std = rx_std.create_solver_ls(meas_std, fast=False)
        
        start_time = time.time()
        for _ in range(20):
            solver_std.step()
        std_time = time.time() - start_time
        res_std = solver_std.get_image()
        solver_std.close()
        rx_std.close()
        
        # 2. Fast CGLS
        # We need FAST measurements for Fast Solver (different PRNG logic)
        tx_fast = holo_api.HoloTx(self.seed, self.width, self.height, self.tx_img)
        meas_fast = tx_fast.generate(n_meas, fast=True)
        tx_fast.close()
        
        rx_fast = holo_api.HoloRx(self.seed, self.width, self.height)
        solver_fast = rx_fast.create_solver_ls(meas_fast, fast=True) # Check API
        
        start_time = time.time()
        for _ in range(20):
            solver_fast.step()
        fast_time = time.time() - start_time
        res_fast = solver_fast.get_image()
        solver_fast.close()
        rx_fast.close()
        
        print(f"Standard CGLS Time: {std_time:.4f}s")
        print(f"Fast CGLS Time: {fast_time:.4f}s")
        
        mse_std = np.mean((res_std.astype(float) - self.tx_img.astype(float))**2)
        mse_fast = np.mean((res_fast.astype(float) - self.tx_img.astype(float))**2)
        
        ssim_std = ssim_metric(self.tx_img, res_std)
        ssim_fast = ssim_metric(self.tx_img, res_fast)
        
        print(f"MSE Standard: {mse_std:.2f} | SSIM: {ssim_std:.4f}")
        print(f"MSE Fast: {mse_fast:.2f}     | SSIM: {ssim_fast:.4f}")
        
        self.assertLess(fast_time, std_time * 0.8, "Fast solver should be at least 20% faster")

    def test_l1_fast(self):
        from utils import ssim_metric
        # Test Fast FISTA
        n_meas = 3000
        tx_fast = holo_api.HoloTx(self.seed, self.width, self.height, self.tx_img)
        meas_fast = tx_fast.generate(n_meas, fast=True)
        tx_fast.close()
        
        rx_fast = holo_api.HoloRx(self.seed, self.width, self.height)
        # lambda=0.1
        solver_l1 = rx_fast.create_solver_l1(meas_fast, lambda_val=2.0, fast=True)
        
        start_time = time.time()
        for _ in range(30):
            solver_l1.step()
        l1_time = time.time() - start_time
        
        res_l1 = solver_l1.get_image()
        solver_l1.close()
        rx_fast.close()
        
        print(f"Fast FISTA Time: {l1_time:.4f}s")
        mse_l1 = np.mean((res_l1.astype(float) - self.tx_img.astype(float))**2)
        ssim_l1 = ssim_metric(self.tx_img, res_l1)
        print(f"MSE Fast L1: {mse_l1:.2f} | SSIM: {ssim_l1:.4f}")
        
        self.assertTrue(np.max(res_l1) > 10, "Output should not be black")

if __name__ == '__main__':
    unittest.main()
